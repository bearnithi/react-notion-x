{"version":3,"sources":["../src/get-text-content.ts","../src/get-block-collection-id.ts","../src/get-block-title.ts","../src/get-block-icon.ts","../src/get-page-title.ts","../src/get-page-property.ts","../src/get-date-value.ts","../src/get-block-parent-page.ts","../src/get-page-table-of-contents.ts","../src/get-page-content-block-ids.ts","../src/id-to-uuid.ts","../src/parse-page-id.ts","../src/uuid-to-id.ts","../src/get-all-pages-in-space.ts","../src/normalize-title.ts","../src/get-canonical-page-id.ts","../src/get-page-breadcrumbs.ts","../src/is-url.ts","../src/get-page-image-urls.ts","../src/normalize-url.ts","../src/merge-record-maps.ts","../src/format-date.ts","../src/format-notion-date-time.ts","../src/estimate-page-read-time.ts"],"sourcesContent":["import * as types from 'notion-types'\r\n\r\n/**\r\n * Gets the raw, unformatted text content of a block's content value.\r\n *\r\n * This is useful, for instance, for extracting a block's `title` without any\r\n * rich text formatting.\r\n */\r\nexport const getTextContent = (text?: types.Decoration[]): string => {\r\n  if (!text) {\r\n    return ''\r\n  } else if (Array.isArray(text)) {\r\n    return (\r\n      text?.reduce(\r\n        (prev, current) =>\r\n          prev + (current[0] !== '⁍' && current[0] !== '‣' ? current[0] : ''),\r\n        ''\r\n      ) ?? ''\r\n    )\r\n  } else {\r\n    return text\r\n  }\r\n}\r\n","import { Block, ExtendedRecordMap } from 'notion-types'\r\n\r\nexport function getBlockCollectionId(\r\n  block: Block,\r\n  recordMap: ExtendedRecordMap\r\n): string | null {\r\n  const collectionId =\r\n    (block as any).collection_id ||\r\n    (block as any).format?.collection_pointer?.id\r\n\r\n  if (collectionId) {\r\n    return collectionId\r\n  }\r\n\r\n  const collectionViewId = (block as any)?.view_ids?.[0]\r\n  if (collectionViewId) {\r\n    const collectionView = recordMap.collection_view?.[collectionViewId]?.value\r\n    if (collectionView) {\r\n      const collectionId = collectionView.format?.collection_pointer?.id\r\n      return collectionId\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n","import { Block, ExtendedRecordMap } from 'notion-types'\r\nimport { getBlockCollectionId } from './get-block-collection-id'\r\nimport { getTextContent } from './get-text-content'\r\n\r\nexport function getBlockTitle(block: Block, recordMap: ExtendedRecordMap) {\r\n  if (block.properties?.title) {\r\n    return getTextContent(block.properties.title)\r\n  }\r\n\r\n  if (\r\n    block.type === 'collection_view_page' ||\r\n    block.type === 'collection_view'\r\n  ) {\r\n    const collectionId = getBlockCollectionId(block, recordMap)\r\n\r\n    if (collectionId) {\r\n      const collection = recordMap.collection[collectionId]?.value\r\n\r\n      if (collection) {\r\n        return getTextContent(collection.name)\r\n      }\r\n    }\r\n  }\r\n\r\n  return ''\r\n}\r\n","import { Block, PageBlock, ExtendedRecordMap } from 'notion-types'\r\nimport { getBlockCollectionId } from './get-block-collection-id'\r\n\r\nexport function getBlockIcon(block: Block, recordMap: ExtendedRecordMap) {\r\n  if ((block as PageBlock).format?.page_icon) {\r\n    return (block as PageBlock).format?.page_icon\r\n  }\r\n\r\n  if (\r\n    block.type === 'collection_view_page' ||\r\n    block.type === 'collection_view'\r\n  ) {\r\n    const collectionId = getBlockCollectionId(block, recordMap)\r\n    if (collectionId) {\r\n      const collection = recordMap.collection[collectionId]?.value\r\n\r\n      if (collection) {\r\n        return collection.icon\r\n      }\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n","import { ExtendedRecordMap } from 'notion-types'\r\nimport { getBlockTitle } from './get-block-title'\r\n\r\nexport function getPageTitle(recordMap: ExtendedRecordMap) {\r\n  const pageBlock = recordMap.block[Object.keys(recordMap.block)[0]]?.value\r\n\r\n  if (pageBlock) {\r\n    return getBlockTitle(pageBlock, recordMap)\r\n  }\r\n\r\n  return null\r\n}\r\n","import { Block, DateFormat, ExtendedRecordMap } from 'notion-types'\r\nimport { getTextContent } from './get-text-content'\r\n\r\n/**\r\n * Gets the value of a collection property for a given page (collection item).\r\n *\r\n * @param propertyName property name\r\n * @param block Page block, often be first block in blockMap\r\n * @param recordMap\r\n * @returns - The return value types will follow the following principles:\r\n *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)\r\n *  2. property is text-like will return `string`\r\n *  3. multi select property will return `string[]`\r\n *  4. checkbox property return `boolean`\r\n * @todo complete all no-text property type\r\n */\r\nexport function getPageProperty<\r\n  T = string | number | boolean | string[] | number[]\r\n>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T\r\nexport function getPageProperty(\r\n  propertyName: string,\r\n  block: Block,\r\n  recordMap: ExtendedRecordMap\r\n) {\r\n  try {\r\n    if (!block.properties || !Object.keys(recordMap.collection)) {\r\n      // console.warn(\r\n      //   `block ${block.id} has no properties or this recordMap has no collection record`\r\n      // )\r\n      return null\r\n    }\r\n\r\n    const collection = recordMap.collection[block.parent_id]?.value\r\n\r\n    if (collection) {\r\n      const propertyNameL = propertyName.toLowerCase()\r\n      const propertyId = Object.keys(collection.schema).find(\r\n        (key) => collection.schema[key]?.name?.toLowerCase() === propertyNameL\r\n      )\r\n\r\n      if (!propertyId) {\r\n        return null\r\n      }\r\n\r\n      const { type } = collection.schema[propertyId]\r\n      const content = getTextContent(block.properties[propertyId])\r\n\r\n      switch (type) {\r\n        case 'created_time':\r\n          return block.created_time\r\n\r\n        case 'multi_select':\r\n          return content.split(',')\r\n\r\n        case 'date': {\r\n          const property = block.properties[propertyId] as [['‣', [DateFormat]]]\r\n          const formatDate = property[0][1][0][1]\r\n\r\n          if (formatDate.type == 'datetime') {\r\n            return new Date(\r\n              `${formatDate.start_date} ${formatDate.start_time}`\r\n            ).getTime()\r\n          } else if (formatDate.type == 'date') {\r\n            return new Date(formatDate.start_date).getTime()\r\n          } else if (formatDate.type == 'datetimerange') {\r\n            const { start_date, start_time, end_date, end_time } = formatDate\r\n            const startTime = new Date(`${start_date} ${start_time}`).getTime()\r\n            const endTime = new Date(`${end_date} ${end_time}`).getTime()\r\n            return [startTime, endTime]\r\n          } else {\r\n            const startTime = new Date(formatDate.start_date).getTime()\r\n            const endTime = new Date(formatDate.end_date).getTime()\r\n            return [startTime, endTime]\r\n          }\r\n        }\r\n\r\n        case 'checkbox':\r\n          return content == 'Yes'\r\n\r\n        case 'last_edited_time':\r\n          return block.last_edited_time\r\n\r\n        default:\r\n          return content\r\n      }\r\n    }\r\n  } catch {\r\n    // ensure that no matter what, we don't throw errors because of an unexpected\r\n    // collection data format\r\n  }\r\n\r\n  return null\r\n}\r\n","import * as types from 'notion-types'\r\n\r\n/**\r\n * Attempts to find a valid date from a given property.\r\n */\r\nexport const getDateValue = (prop: any[]): types.FormattedDate | null => {\r\n  if (prop && Array.isArray(prop)) {\r\n    if (prop[0] === 'd') {\r\n      return prop[1]\r\n    } else {\r\n      for (const v of prop) {\r\n        const value = getDateValue(v)\r\n        if (value) {\r\n          return value\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n","import * as types from 'notion-types'\r\n\r\n/**\r\n * Returns the parent page block containing a given page.\r\n *\r\n * Note that many times this will not be the direct parent block since\r\n * some non-page content blocks can contain sub-blocks.\r\n */\r\nexport const getBlockParentPage = (\r\n  block: types.Block,\r\n  recordMap: types.ExtendedRecordMap,\r\n  {\r\n    inclusive = false\r\n  }: {\r\n    inclusive?: boolean\r\n  } = {}\r\n): types.PageBlock | null => {\r\n  let currentRecord: types.Block | types.Collection = block\r\n\r\n  while (currentRecord != null) {\r\n    if (inclusive && (currentRecord as types.Block)?.type === 'page') {\r\n      return currentRecord as types.PageBlock\r\n    }\r\n\r\n    const parentId: string = currentRecord.parent_id\r\n    const parentTable = currentRecord.parent_table\r\n\r\n    if (!parentId) {\r\n      break\r\n    }\r\n\r\n    if (parentTable === 'collection') {\r\n      currentRecord = recordMap.collection[parentId]?.value\r\n    } else {\r\n      currentRecord = recordMap.block[parentId]?.value\r\n\r\n      if ((currentRecord as types.Block)?.type === 'page') {\r\n        return currentRecord as types.PageBlock\r\n      }\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n","import * as types from 'notion-types'\r\nimport { getTextContent } from './get-text-content'\r\n\r\nexport interface TableOfContentsEntry {\r\n  id: types.ID\r\n  type: types.BlockType\r\n  text: string\r\n  indentLevel: number\r\n}\r\n\r\nconst indentLevels = {\r\n  header: 0,\r\n  sub_header: 1,\r\n  sub_sub_header: 2\r\n}\r\n\r\n/**\r\n * Gets the metadata for a table of contents block by parsing the page's\r\n * H1, H2, and H3 elements.\r\n */\r\nexport const getPageTableOfContents = (\r\n  page: types.PageBlock,\r\n  recordMap: types.ExtendedRecordMap\r\n): Array<TableOfContentsEntry> => {\r\n  const toc = (page.content ?? [])\r\n    .map((blockId: string) => {\r\n      const block = recordMap.block[blockId]?.value\r\n\r\n      if (block) {\r\n        const { type } = block\r\n\r\n        if (\r\n          type === 'header' ||\r\n          type === 'sub_header' ||\r\n          type === 'sub_sub_header'\r\n        ) {\r\n          return {\r\n            id: blockId,\r\n            type,\r\n            text: getTextContent(block.properties?.title),\r\n            indentLevel: indentLevels[type]\r\n          }\r\n        }\r\n      }\r\n\r\n      return null\r\n    })\r\n    .filter(Boolean) as Array<TableOfContentsEntry>\r\n\r\n  const indentLevelStack = [\r\n    {\r\n      actual: -1,\r\n      effective: -1\r\n    }\r\n  ]\r\n\r\n  // Adjust indent levels to always change smoothly.\r\n  // This is a little tricky, but the key is that when increasing indent levels,\r\n  // they should never jump more than one at a time.\r\n  for (const tocItem of toc) {\r\n    const { indentLevel } = tocItem\r\n    const actual = indentLevel\r\n\r\n    do {\r\n      const prevIndent = indentLevelStack[indentLevelStack.length - 1]\r\n      const { actual: prevActual, effective: prevEffective } = prevIndent\r\n\r\n      if (actual > prevActual) {\r\n        tocItem.indentLevel = prevEffective + 1\r\n        indentLevelStack.push({\r\n          actual,\r\n          effective: tocItem.indentLevel\r\n        })\r\n      } else if (actual === prevActual) {\r\n        tocItem.indentLevel = prevEffective\r\n        break\r\n      } else {\r\n        indentLevelStack.pop()\r\n      }\r\n\r\n      // eslint-disable-next-line no-constant-condition\r\n    } while (true)\r\n  }\r\n\r\n  return toc\r\n}\r\n","import * as types from 'notion-types'\r\n\r\n/**\r\n * Gets the IDs of all blocks contained on a page starting from a root block ID.\r\n */\r\nexport const getPageContentBlockIds = (\r\n  recordMap: types.ExtendedRecordMap,\r\n  blockId?: string\r\n): string[] => {\r\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0]\r\n  const contentBlockIds = new Set<string>()\r\n\r\n  function addContentBlocks(blockId: string) {\r\n    if (contentBlockIds.has(blockId)) return\r\n    contentBlockIds.add(blockId)\r\n\r\n    const block = recordMap.block[blockId]?.value\r\n    if (!block) return\r\n\r\n    const { content, type, properties, format } = block\r\n    if (properties) {\r\n      // TODO: this needs some love, especially for resolving relation properties\r\n      // see this collection_view_page for an example: 8a586d253f984b85b48254da84465d23\r\n      for (const key of Object.keys(properties)) {\r\n        const p = properties[key]\r\n        p.map((d: any) => {\r\n          const value = d?.[0]?.[1]?.[0]\r\n          if (value?.[0] === 'p' && value[1]) {\r\n            addContentBlocks(value[1])\r\n          }\r\n        })\r\n\r\n        // [[\"‣\", [[\"p\", \"841918aa-f2a3-4d4c-b5ad-64b0f57c47b8\"]]]]\r\n        const value = p?.[0]?.[1]?.[0]\r\n\r\n        if (value?.[0] === 'p' && value[1]) {\r\n          addContentBlocks(value[1])\r\n        }\r\n      }\r\n    }\r\n\r\n    if (format) {\r\n      const referenceId = format.transclusion_reference_pointer?.id\r\n      if (referenceId) {\r\n        addContentBlocks(referenceId)\r\n      }\r\n    }\r\n\r\n    if (!content || !Array.isArray(content)) {\r\n      // no child content blocks to recurse on\r\n      return\r\n    }\r\n\r\n    if (blockId !== rootBlockId) {\r\n      if (type === 'page' || type === 'collection_view_page') {\r\n        // ignore the content of other pages and collections\r\n        return\r\n      }\r\n    }\r\n\r\n    for (const blockId of content) {\r\n      addContentBlocks(blockId)\r\n    }\r\n  }\r\n\r\n  addContentBlocks(rootBlockId)\r\n  return Array.from(contentBlockIds)\r\n}\r\n","export const idToUuid = (id = '') =>\r\n  `${id.substr(0, 8)}-${id.substr(8, 4)}-${id.substr(12, 4)}-${id.substr(\r\n    16,\r\n    4\r\n  )}-${id.substr(20)}`\r\n","import { idToUuid } from './id-to-uuid'\r\n\r\nconst pageIdRe = /\\b([a-f0-9]{32})\\b/\r\nconst pageId2Re =\r\n  /\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/\r\n\r\n/**\r\n * Robustly extracts the notion page ID from a notion URL or pathname suffix.\r\n *\r\n * Defaults to returning a UUID (with dashes).\r\n */\r\nexport const parsePageId = (\r\n  id: string | null = '',\r\n  { uuid = true }: { uuid?: boolean } = {}\r\n) => {\r\n  if (!id) {\r\n    return null\r\n  }\r\n\r\n  id = id.split('?')[0]\r\n  const match = id.match(pageIdRe)\r\n\r\n  if (match) {\r\n    return uuid ? idToUuid(match[1]) : match[1]\r\n  }\r\n\r\n  const match2 = id.match(pageId2Re)\r\n  if (match2) {\r\n    return uuid ? match2[1] : match2[1].replace(/-/g, '')\r\n  }\r\n\r\n  return null\r\n}\r\n","export const uuidToId = (uuid: string) => uuid.replace(/-/g, '')\r\n","import PQueue from 'p-queue'\r\n\r\nimport { ExtendedRecordMap, PageMap } from 'notion-types'\r\nimport { parsePageId } from './parse-page-id'\r\n\r\n/**\r\n * Performs a traversal over a given Notion workspace starting from a seed page.\r\n *\r\n * Returns a map containing all of the pages that are reachable from the seed\r\n * page in the space.\r\n *\r\n * If `rootSpaceId` is not defined, the space ID of the root page will be used\r\n * to scope traversal.\r\n *\r\n *\r\n * @param rootPageId - Page ID to start from.\r\n * @param rootSpaceId - Space ID to scope traversal.\r\n * @param getPage - Function used to fetch a single page.\r\n * @param opts - Optional config\r\n */\r\nexport async function getAllPagesInSpace(\r\n  rootPageId: string,\r\n  rootSpaceId: string | undefined,\r\n  getPage: (pageId: string) => Promise<ExtendedRecordMap>,\r\n  {\r\n    concurrency = 4,\r\n    traverseCollections = true,\r\n    targetPageId = null\r\n  }: {\r\n    concurrency?: number\r\n    traverseCollections?: boolean\r\n    targetPageId?: string\r\n  } = {}\r\n): Promise<PageMap> {\r\n  const pages: PageMap = {}\r\n  const pendingPageIds = new Set<string>()\r\n  const queue = new PQueue({ concurrency })\r\n\r\n  async function processPage(pageId: string) {\r\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\r\n      return\r\n    }\r\n\r\n    pageId = parsePageId(pageId) as string\r\n\r\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\r\n      pendingPageIds.add(pageId)\r\n\r\n      queue.add(async () => {\r\n        try {\r\n          if (\r\n            targetPageId &&\r\n            pendingPageIds.has(targetPageId) &&\r\n            pageId !== targetPageId\r\n          ) {\r\n            return\r\n          }\r\n\r\n          const page = await getPage(pageId)\r\n          if (!page) {\r\n            return\r\n          }\r\n\r\n          const spaceId = page.block[pageId]?.value?.space_id\r\n\r\n          if (spaceId) {\r\n            if (!rootSpaceId) {\r\n              rootSpaceId = spaceId\r\n            } else if (rootSpaceId !== spaceId) {\r\n              return\r\n            }\r\n          }\r\n\r\n          Object.keys(page.block)\r\n            .filter((key) => {\r\n              const block = page.block[key]?.value\r\n              if (!block) return false\r\n\r\n              if (\r\n                block.type !== 'page' &&\r\n                block.type !== 'collection_view_page'\r\n              ) {\r\n                return false\r\n              }\r\n\r\n              // the space id check is important to limit traversal because pages\r\n              // can reference pages in other spaces\r\n              if (\r\n                rootSpaceId &&\r\n                block.space_id &&\r\n                block.space_id !== rootSpaceId\r\n              ) {\r\n                return false\r\n              }\r\n\r\n              return true\r\n            })\r\n            .forEach((subPageId) => processPage(subPageId))\r\n\r\n          // traverse collection item pages as they may contain subpages as well\r\n          if (traverseCollections) {\r\n            for (const collectionViews of Object.values(\r\n              page.collection_query\r\n            )) {\r\n              for (const collectionData of Object.values(collectionViews)) {\r\n                const { blockIds } = collectionData\r\n\r\n                if (blockIds) {\r\n                  for (const collectionItemId of blockIds) {\r\n                    processPage(collectionItemId)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          pages[pageId] = page\r\n        } catch (err) {\r\n          console.warn(\r\n            'page load error',\r\n            { pageId, spaceId: rootSpaceId },\r\n            err.statusCode,\r\n            err.message\r\n          )\r\n          pages[pageId] = null\r\n        }\r\n\r\n        pendingPageIds.delete(pageId)\r\n      })\r\n    }\r\n  }\r\n\r\n  await processPage(rootPageId)\r\n  await queue.onIdle()\r\n\r\n  return pages\r\n}\r\n","export const normalizeTitle = (title?: string | null): string => {\r\n  return (title || '')\r\n    .replace(/ /g, '-')\r\n    .replace(/[^a-zA-Z0-9-\\u4e00-\\u9fa5]/g, '')\r\n    .replace(/--/g, '-')\r\n    .replace(/-$/, '')\r\n    .replace(/^-/, '')\r\n    .trim()\r\n    .toLowerCase()\r\n}\r\n","import { ExtendedRecordMap } from 'notion-types'\r\nimport { uuidToId } from './uuid-to-id'\r\nimport { getBlockTitle } from './get-block-title'\r\nimport { getPageProperty } from './get-page-property'\r\nimport { normalizeTitle } from './normalize-title'\r\n\r\n/**\r\n * Gets the canonical, display-friendly version of a page's ID for use in URLs.\r\n */\r\nexport const getCanonicalPageId = (\r\n  pageId: string,\r\n  recordMap: ExtendedRecordMap,\r\n  { uuid = true }: { uuid?: boolean } = {}\r\n): string | null => {\r\n  if (!pageId || !recordMap) return null\r\n\r\n  const id = uuidToId(pageId)\r\n  const block = recordMap.block[pageId]?.value\r\n\r\n  if (block) {\r\n    const slug =\r\n      (getPageProperty('slug', block, recordMap) as string | null) ||\r\n      (getPageProperty('Slug', block, recordMap) as string | null) ||\r\n      normalizeTitle(getBlockTitle(block, recordMap))\r\n\r\n    if (slug) {\r\n      if (uuid) {\r\n        return `${slug}-${id}`\r\n      } else {\r\n        return slug\r\n      }\r\n    }\r\n  }\r\n\r\n  return id\r\n}\r\n","import * as types from 'notion-types'\r\nimport { getBlockTitle } from './get-block-title'\r\nimport { getBlockIcon } from './get-block-icon'\r\nimport { getBlockParentPage } from './get-block-parent-page'\r\n\r\nexport const getPageBreadcrumbs = (\r\n  recordMap: types.ExtendedRecordMap,\r\n  activePageId: string\r\n): Array<any> | null => {\r\n  const blockMap = recordMap.block\r\n  const breadcrumbs = []\r\n\r\n  let currentPageId = activePageId\r\n\r\n  do {\r\n    const block = blockMap[currentPageId]?.value\r\n    if (!block) {\r\n      break\r\n    }\r\n\r\n    const title = getBlockTitle(block, recordMap)\r\n    const icon = getBlockIcon(block, recordMap)\r\n\r\n    if (!(title || icon)) {\r\n      break\r\n    }\r\n\r\n    breadcrumbs.push({\r\n      block,\r\n      active: currentPageId === activePageId,\r\n      pageId: currentPageId,\r\n      title,\r\n      icon\r\n    })\r\n\r\n    const parentBlock = getBlockParentPage(block, recordMap)\r\n    const parentId = parentBlock?.id\r\n\r\n    if (!parentId) {\r\n      break\r\n    }\r\n\r\n    currentPageId = parentId\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n  } while (true)\r\n\r\n  breadcrumbs.reverse()\r\n\r\n  return breadcrumbs\r\n}\r\n","import isUrl from 'is-url-superb'\r\n\r\nexport { isUrl }\r\n","import * as types from 'notion-types'\r\nimport { isUrl } from './is-url'\r\nimport { getBlockIcon } from './get-block-icon'\r\n\r\n/**\r\n * Gets URLs of all images contained on the given page.\r\n */\r\nexport const getPageImageUrls = (\r\n  recordMap: types.ExtendedRecordMap,\r\n  {\r\n    mapImageUrl\r\n  }: {\r\n    mapImageUrl: (url: string, block: types.Block) => string | null\r\n  }\r\n): string[] => {\r\n  const blockIds = Object.keys(recordMap.block)\r\n  const imageUrls: string[] = blockIds\r\n    .flatMap((blockId) => {\r\n      const block = recordMap.block[blockId]?.value\r\n      const images: Array<{ block: types.Block; url: string }> = []\r\n\r\n      if (block) {\r\n        if (block.type === 'image') {\r\n          const signedUrl = recordMap.signed_urls?.[block.id]\r\n          const source = signedUrl || block.properties?.source?.[0]?.[0]\r\n\r\n          if (source) {\r\n            images.push({\r\n              block,\r\n              url: source\r\n            })\r\n          }\r\n        }\r\n\r\n        if ((block.format as any)?.page_cover) {\r\n          const source = (block.format as any).page_cover\r\n\r\n          images.push({\r\n            block,\r\n            url: source\r\n          })\r\n        }\r\n\r\n        if ((block.format as any)?.bookmark_cover) {\r\n          const source = (block.format as any).bookmark_cover\r\n\r\n          images.push({\r\n            block,\r\n            url: source\r\n          })\r\n        }\r\n\r\n        if ((block.format as any)?.bookmark_icon) {\r\n          const source = (block.format as any).bookmark_icon\r\n\r\n          images.push({\r\n            block,\r\n            url: source\r\n          })\r\n        }\r\n\r\n        const pageIcon = getBlockIcon(block, recordMap)\r\n        if (pageIcon && isUrl(pageIcon)) {\r\n          images.push({\r\n            block,\r\n            url: pageIcon\r\n          })\r\n        }\r\n      }\r\n\r\n      return images\r\n    })\r\n    .filter(Boolean)\r\n    .map(({ block, url }) => mapImageUrl(url, block))\r\n    .filter(Boolean)\r\n\r\n  return Array.from(new Set(imageUrls))\r\n}\r\n","import normalizeUrlImpl from 'normalize-url'\r\nimport mem from 'mem'\r\n\r\nexport const normalizeUrl = mem((url?: string) => {\r\n  if (!url) {\r\n    return ''\r\n  }\r\n\r\n  try {\r\n    if (url.startsWith('https://www.notion.so/image/')) {\r\n      const u = new URL(url)\r\n      const subUrl = decodeURIComponent(u.pathname.substr('/image/'.length))\r\n      const normalizedSubUrl = normalizeUrl(subUrl)\r\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`\r\n      url = u.toString()\r\n    }\r\n\r\n    return normalizeUrlImpl(url, {\r\n      stripProtocol: true,\r\n      stripWWW: true,\r\n      stripHash: true,\r\n      stripTextFragment: true,\r\n      removeQueryParameters: true\r\n    })\r\n  } catch (err) {\r\n    return ''\r\n  }\r\n})\r\n","import { ExtendedRecordMap } from 'notion-types'\r\n\r\nexport function mergeRecordMaps(\r\n  recordMapA: ExtendedRecordMap,\r\n  recordMapB: ExtendedRecordMap\r\n): ExtendedRecordMap {\r\n  const mergedRecordMap: ExtendedRecordMap = {\r\n    block: {\r\n      ...recordMapA.block,\r\n      ...recordMapB.block\r\n    },\r\n    collection: {\r\n      ...recordMapA.collection,\r\n      ...recordMapB.collection\r\n    },\r\n    collection_view: {\r\n      ...recordMapA.collection_view,\r\n      ...recordMapB.collection_view\r\n    },\r\n    notion_user: {\r\n      ...recordMapA.notion_user,\r\n      ...recordMapB.notion_user\r\n    },\r\n    collection_query: {\r\n      ...recordMapA.collection_query,\r\n      ...recordMapB.collection_query\r\n    },\r\n    signed_urls: {\r\n      ...recordMapA.signed_urls,\r\n      ...recordMapB.signed_urls\r\n    },\r\n    preview_images: {\r\n      ...recordMapA.preview_images,\r\n      ...recordMapB.preview_images\r\n    }\r\n  }\r\n\r\n  return mergedRecordMap\r\n}\r\n","export const formatDate = (\r\n  input: string | number,\r\n  { month = 'short' }: { month?: 'long' | 'short' } = {}\r\n) => {\r\n  const date = new Date(input)\r\n  const monthLocale = date.toLocaleString('en-US', { month })\r\n  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`\r\n}\r\n","import { formatDate } from './format-date'\r\n\r\nexport interface NotionDateTime {\r\n  type: 'datetime'\r\n  start_date: string\r\n  start_time?: string\r\n  time_zone?: string\r\n}\r\n\r\nexport const formatNotionDateTime = (datetime: NotionDateTime) => {\r\n  const dateString = `${datetime.start_time || ''} ${datetime.start_date} ${\r\n    datetime.time_zone || ''\r\n  }`\r\n  return formatDate(dateString)\r\n}\r\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\r\nimport { getBlockTitle } from './get-block-title'\r\nimport { getPageTableOfContents } from './get-page-table-of-contents'\r\n\r\ntype EstimatePageReadTimeOptions = {\r\n  wordsPerMinute?: number\r\n  imageReadTimeInSeconds?: number\r\n}\r\n\r\ntype ContentStats = {\r\n  numWords: number\r\n  numImages: number\r\n}\r\n\r\ntype PageReadTimeEstimate = ContentStats & {\r\n  totalWordsReadTimeInMinutes: number\r\n  totalImageReadTimeInMinutes: number\r\n  totalReadTimeInMinutes: number\r\n}\r\n\r\n/**\r\n * Returns an estimate for the time it would take for a person to read the content\r\n * in the given Notion page.\r\n *\r\n * Uses Medium for inspiration.\r\n *\r\n * @see https://blog.medium.com/read-time-and-you-bc2048ab620c\r\n * @see https://github.com/ngryman/reading-time\r\n *\r\n * TODO: handle non-english content.\r\n */\r\nexport function estimatePageReadTime(\r\n  block: Block,\r\n  recordMap: ExtendedRecordMap,\r\n  {\r\n    wordsPerMinute = 275,\r\n    imageReadTimeInSeconds = 12\r\n  }: EstimatePageReadTimeOptions = {}\r\n): PageReadTimeEstimate {\r\n  const stats = getBlockContentStats(block, recordMap)\r\n  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute\r\n  const totalImageReadTimeInSeconds =\r\n    stats.numImages > 10\r\n      ? (stats.numImages / 2) * (imageReadTimeInSeconds + 3) +\r\n        (stats.numImages - 10) * 3 // n/2(a+b) + 3 sec/image\r\n      : (stats.numImages / 2) *\r\n        (2 * imageReadTimeInSeconds + (1 - stats.numImages)) // n/2[2a+(n-1)d]\r\n  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60\r\n\r\n  const totalReadTimeInMinutes =\r\n    totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes\r\n\r\n  return {\r\n    ...stats,\r\n    totalWordsReadTimeInMinutes,\r\n    totalImageReadTimeInMinutes,\r\n    totalReadTimeInMinutes\r\n  }\r\n}\r\n\r\n/**\r\n * Same as `estimatePageReadTime`, except it returns the total time estimate as\r\n * a human-readable string.\r\n *\r\n * For example, \"9 minutes\" or \"less than a minute\".\r\n */\r\nexport function estimatePageReadTimeAsHumanizedString(\r\n  block: Block,\r\n  recordMap: ExtendedRecordMap,\r\n  opts: EstimatePageReadTimeOptions\r\n) {\r\n  const estimate = estimatePageReadTime(block, recordMap, opts)\r\n  return humanizeReadTime(estimate.totalReadTimeInMinutes)\r\n}\r\n\r\nfunction getBlockContentStats(\r\n  block: Block,\r\n  recordMap: ExtendedRecordMap\r\n): ContentStats {\r\n  const stats: ContentStats = {\r\n    numWords: 0,\r\n    numImages: 0\r\n  }\r\n\r\n  if (!block) {\r\n    return stats\r\n  }\r\n\r\n  for (const childId of block.content || []) {\r\n    const child = recordMap.block[childId]?.value\r\n    let recurse = false\r\n    if (!child) continue\r\n\r\n    switch (child.type) {\r\n      case 'quote':\r\n      // fallthrough\r\n      case 'alias':\r\n      // fallthrough\r\n      case 'header':\r\n      // fallthrough\r\n      case 'sub_header':\r\n      // fallthrough\r\n      case 'sub_sub_header': {\r\n        const title = getBlockTitle(child, recordMap)\r\n        stats.numWords += countWordsInText(title)\r\n        break\r\n      }\r\n\r\n      case 'callout':\r\n      // fallthrough\r\n      case 'toggle':\r\n      // fallthrough\r\n      case 'to_do':\r\n      // fallthrough\r\n      case 'bulleted_list':\r\n      // fallthrough\r\n      case 'numbered_list':\r\n      // fallthrough\r\n      case 'text': {\r\n        const title = getBlockTitle(child, recordMap)\r\n        stats.numWords += countWordsInText(title)\r\n        recurse = true\r\n        break\r\n      }\r\n\r\n      case 'embed':\r\n      // fallthrough\r\n      case 'tweet':\r\n      // fallthrough\r\n      case 'maps':\r\n      // fallthrough\r\n      case 'pdf':\r\n      // fallthrough\r\n      case 'figma':\r\n      // fallthrough\r\n      case 'typeform':\r\n      // fallthrough\r\n      case 'codepen':\r\n      // fallthrough\r\n      case 'excalidraw':\r\n      // fallthrough\r\n      case 'gist':\r\n      // fallthrough\r\n      case 'video':\r\n      // fallthrough\r\n      case 'drive':\r\n      // fallthrough\r\n      case 'audio':\r\n      // fallthrough\r\n      case 'file':\r\n      // fallthrough\r\n      case 'image':\r\n        // treat all embeds as images\r\n        stats.numImages += 1\r\n        break\r\n\r\n      case 'bookmark':\r\n        // treat bookmarks as quarter images since they aren't as content-ful as embedd images\r\n        stats.numImages += 0.25\r\n        break\r\n\r\n      case 'code':\r\n        // treat code blocks as double the complexity of images\r\n        stats.numImages += 2\r\n        break\r\n\r\n      case 'table':\r\n      // fallthrough\r\n      case 'collection_view':\r\n        // treat collection views as double the complexity of images\r\n        stats.numImages += 2\r\n        break\r\n\r\n      case 'column':\r\n      // fallthrough\r\n      case 'column_list':\r\n      // fallthrough\r\n      case 'transclusion_container':\r\n        recurse = true\r\n        break\r\n\r\n      case 'table_of_contents': {\r\n        const page = block as PageBlock\r\n        if (!page) continue\r\n\r\n        const toc = getPageTableOfContents(page, recordMap)\r\n        for (const tocItem of toc) {\r\n          stats.numWords += countWordsInText(tocItem.text)\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'transclusion_reference': {\r\n        const referencePointerId =\r\n          child?.format?.transclusion_reference_pointer?.id\r\n\r\n        if (!referencePointerId) {\r\n          continue\r\n        }\r\n        const referenceBlock = recordMap.block[referencePointerId]?.value\r\n        if (referenceBlock) {\r\n          mergeContentStats(\r\n            stats,\r\n            getBlockContentStats(referenceBlock, recordMap)\r\n          )\r\n        }\r\n        break\r\n      }\r\n\r\n      default:\r\n        // ignore unrecognized blocks\r\n        break\r\n    }\r\n\r\n    if (recurse) {\r\n      mergeContentStats(stats, getBlockContentStats(child, recordMap))\r\n    }\r\n  }\r\n\r\n  return stats\r\n}\r\n\r\nfunction mergeContentStats(statsA: ContentStats, statsB: ContentStats) {\r\n  statsA.numWords += statsB.numWords\r\n  statsA.numImages += statsB.numImages\r\n}\r\n\r\nfunction countWordsInText(text: string): number {\r\n  if (!text) {\r\n    return 0\r\n  }\r\n\r\n  return (text.match(/\\w+/g) || []).length\r\n}\r\n\r\nfunction humanizeReadTime(time: number): string {\r\n  if (time < 0.5) {\r\n    return 'less than a minute'\r\n  }\r\n\r\n  if (time < 1.5) {\r\n    return '1 minute'\r\n  }\r\n\r\n  return `${Math.ceil(time)} minutes`\r\n}\r\n"],"mappings":"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","names":[]}
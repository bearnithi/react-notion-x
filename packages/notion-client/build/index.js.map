{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\r\nimport got, { OptionsOfJSONResponseBody } from 'got'\r\nimport pMap from 'p-map'\r\n\r\nimport {\r\n  parsePageId,\r\n  getPageContentBlockIds,\r\n  uuidToId,\r\n  getBlockCollectionId\r\n} from 'notion-utils'\r\nimport * as notion from 'notion-types'\r\n\r\nimport * as types from './types'\r\n\r\n/**\r\n * Main Notion API client.\r\n */\r\nexport class NotionAPI {\r\n  private readonly _apiBaseUrl: string\r\n  private readonly _authToken?: string\r\n  private readonly _activeUser?: string\r\n  private readonly _userTimeZone: string\r\n\r\n  constructor({\r\n    apiBaseUrl = 'https://www.notion.so/api/v3',\r\n    authToken,\r\n    activeUser,\r\n    userTimeZone = 'America/New_York'\r\n  }: {\r\n    apiBaseUrl?: string\r\n    authToken?: string\r\n    userLocale?: string\r\n    userTimeZone?: string\r\n    activeUser?: string\r\n  } = {}) {\r\n    this._apiBaseUrl = apiBaseUrl\r\n    this._authToken = authToken\r\n    this._activeUser = activeUser\r\n    this._userTimeZone = userTimeZone\r\n  }\r\n\r\n  public async getPage(\r\n    pageId: string,\r\n    {\r\n      concurrency = 3,\r\n      fetchMissingBlocks = true,\r\n      fetchCollections = true,\r\n      signFileUrls = true,\r\n      chunkLimit = 100,\r\n      chunkNumber = 0,\r\n      gotOptions\r\n    }: {\r\n      concurrency?: number\r\n      fetchMissingBlocks?: boolean\r\n      fetchCollections?: boolean\r\n      signFileUrls?: boolean\r\n      chunkLimit?: number\r\n      chunkNumber?: number\r\n      gotOptions?: OptionsOfJSONResponseBody\r\n    } = {}\r\n  ): Promise<notion.ExtendedRecordMap> {\r\n    const page = await this.getPageRaw(pageId, {\r\n      chunkLimit,\r\n      chunkNumber,\r\n      gotOptions\r\n    })\r\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\r\n\r\n    if (!recordMap?.block) {\r\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\r\n    }\r\n\r\n    // ensure that all top-level maps exist\r\n    recordMap.collection = recordMap.collection ?? {}\r\n    recordMap.collection_view = recordMap.collection_view ?? {}\r\n    recordMap.notion_user = recordMap.notion_user ?? {}\r\n\r\n    // additional mappings added for convenience\r\n    // note: these are not native notion objects\r\n    recordMap.collection_query = {}\r\n    recordMap.signed_urls = {}\r\n\r\n    if (fetchMissingBlocks) {\r\n      // eslint-disable-next-line no-constant-condition\r\n      while (true) {\r\n        // fetch any missing content blocks\r\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\r\n          (id) => !recordMap.block[id]\r\n        )\r\n\r\n        if (!pendingBlockIds.length) {\r\n          break\r\n        }\r\n\r\n        const newBlocks = await this.getBlocks(\r\n          pendingBlockIds,\r\n          gotOptions\r\n        ).then((res) => res.recordMap.block)\r\n\r\n        recordMap.block = { ...recordMap.block, ...newBlocks }\r\n      }\r\n    }\r\n\r\n    const contentBlockIds = getPageContentBlockIds(recordMap)\r\n\r\n    // Optionally fetch all data for embedded collections and their associated views.\r\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\r\n    // This is really convenient in order to ensure that all data needed for a given\r\n    // Notion page is readily available for use cases involving server-side rendering\r\n    // and edge caching.\r\n    if (fetchCollections) {\r\n      const allCollectionInstances: Array<{\r\n        collectionId: string\r\n        collectionViewId: string\r\n      }> = contentBlockIds.flatMap((blockId) => {\r\n        const block = recordMap.block[blockId].value\r\n        const collectionId =\r\n          block &&\r\n          (block.type === 'collection_view' ||\r\n            block.type === 'collection_view_page') &&\r\n          getBlockCollectionId(block, recordMap)\r\n\r\n        if (collectionId) {\r\n          return block.view_ids?.map((collectionViewId) => ({\r\n            collectionId,\r\n            collectionViewId\r\n          }))\r\n        } else {\r\n          return []\r\n        }\r\n      })\r\n\r\n      // fetch data for all collection view instances\r\n      await pMap(\r\n        allCollectionInstances,\r\n        async (collectionInstance) => {\r\n          const { collectionId, collectionViewId } = collectionInstance\r\n          const collectionView =\r\n            recordMap.collection_view[collectionViewId]?.value\r\n\r\n          try {\r\n            const collectionData = await this.getCollectionData(\r\n              collectionId,\r\n              collectionViewId,\r\n              collectionView,\r\n              {\r\n                gotOptions\r\n              }\r\n            )\r\n\r\n            // await fs.writeFile(\r\n            //   `${collectionId}-${collectionViewId}.json`,\r\n            //   JSON.stringify(collectionData.result, null, 2)\r\n            // )\r\n\r\n            recordMap.block = {\r\n              ...recordMap.block,\r\n              ...collectionData.recordMap.block\r\n            }\r\n\r\n            recordMap.collection = {\r\n              ...recordMap.collection,\r\n              ...collectionData.recordMap.collection\r\n            }\r\n\r\n            recordMap.collection_view = {\r\n              ...recordMap.collection_view,\r\n              ...collectionData.recordMap.collection_view\r\n            }\r\n\r\n            recordMap.notion_user = {\r\n              ...recordMap.notion_user,\r\n              ...collectionData.recordMap.notion_user\r\n            }\r\n\r\n            recordMap.collection_query![collectionId] = {\r\n              ...recordMap.collection_query![collectionId],\r\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\r\n            }\r\n          } catch (err) {\r\n            // It's possible for public pages to link to private collections, in which case\r\n            // Notion returns a 400 error\r\n            console.warn('NotionAPI collectionQuery error', pageId, err.message)\r\n            console.error(err)\r\n          }\r\n        },\r\n        {\r\n          concurrency\r\n        }\r\n      )\r\n    }\r\n\r\n    // Optionally fetch signed URLs for any embedded files.\r\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\r\n    // because it is preferable for many use cases as opposed to making these API calls\r\n    // lazily from the client-side.\r\n    if (signFileUrls) {\r\n      await this.addSignedUrls({ recordMap, contentBlockIds, gotOptions })\r\n    }\r\n\r\n    return recordMap\r\n  }\r\n\r\n  public async addSignedUrls({\r\n    recordMap,\r\n    contentBlockIds,\r\n    gotOptions = {}\r\n  }: {\r\n    recordMap: notion.ExtendedRecordMap\r\n    contentBlockIds?: string[]\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n  }) {\r\n    recordMap.signed_urls = {}\r\n\r\n    if (!contentBlockIds) {\r\n      contentBlockIds = getPageContentBlockIds(recordMap)\r\n    }\r\n\r\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\r\n      const block = recordMap.block[blockId]?.value\r\n\r\n      if (\r\n        block &&\r\n        (block.type === 'pdf' ||\r\n          block.type === 'audio' ||\r\n          (block.type === 'image' && block.file_ids?.length) ||\r\n          block.type === 'video' ||\r\n          block.type === 'file' ||\r\n          block.type === 'page')\r\n      ) {\r\n        const source =\r\n          block.type === 'page'\r\n            ? block.format?.page_cover\r\n            : block.properties?.source?.[0]?.[0]\r\n        // console.log(block, source)\r\n\r\n        if (source) {\r\n          if (!source.includes('secure.notion-static.com')) {\r\n            return []\r\n          }\r\n\r\n          return {\r\n            permissionRecord: {\r\n              table: 'block',\r\n              id: block.id\r\n            },\r\n            url: source\r\n          }\r\n        }\r\n      }\r\n\r\n      return []\r\n    })\r\n\r\n    if (allFileInstances.length > 0) {\r\n      try {\r\n        const { signedUrls } = await this.getSignedFileUrls(\r\n          allFileInstances,\r\n          gotOptions\r\n        )\r\n\r\n        if (signedUrls.length === allFileInstances.length) {\r\n          for (let i = 0; i < allFileInstances.length; ++i) {\r\n            const file = allFileInstances[i]\r\n            const signedUrl = signedUrls[i]\r\n\r\n            recordMap.signed_urls[file.permissionRecord.id] = signedUrl\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.warn('NotionAPI getSignedfileUrls error', err)\r\n      }\r\n    }\r\n  }\r\n\r\n  public async getPageRaw(\r\n    pageId: string,\r\n    {\r\n      gotOptions,\r\n      chunkLimit = 100,\r\n      chunkNumber = 0\r\n    }: {\r\n      chunkLimit?: number\r\n      chunkNumber?: number\r\n      gotOptions?: OptionsOfJSONResponseBody\r\n    } = {}\r\n  ) {\r\n    const parsedPageId = parsePageId(pageId)\r\n\r\n    if (!parsedPageId) {\r\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\r\n    }\r\n\r\n    const body = {\r\n      pageId: parsedPageId,\r\n      limit: chunkLimit,\r\n      chunkNumber: chunkNumber,\r\n      cursor: { stack: [] },\r\n      verticalColumns: false\r\n    }\r\n\r\n    return this.fetch<notion.PageChunk>({\r\n      endpoint: 'loadPageChunk',\r\n      body,\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async getCollectionData(\r\n    collectionId: string,\r\n    collectionViewId: string,\r\n    collectionView: any,\r\n    {\r\n      limit = 9999,\r\n      searchQuery = '',\r\n      userTimeZone = this._userTimeZone,\r\n      loadContentCover = true,\r\n      gotOptions\r\n    }: {\r\n      type?: notion.CollectionViewType\r\n      limit?: number\r\n      searchQuery?: string\r\n      userTimeZone?: string\r\n      userLocale?: string\r\n      loadContentCover?: boolean\r\n      gotOptions?: OptionsOfJSONResponseBody\r\n    } = {}\r\n  ) {\r\n    const type = collectionView?.type\r\n    const isBoardType = type === 'board'\r\n    const groupBy = isBoardType\r\n      ? collectionView?.format?.board_columns_by\r\n      : collectionView?.format?.collection_group_by\r\n\r\n    let filters = []\r\n    if (collectionView.format?.property_filters) {\r\n      filters = collectionView.format?.property_filters.map((filterObj) => {\r\n        //get the inner filter\r\n        return {\r\n          filter: filterObj?.filter?.filter,\r\n          property: filterObj?.filter?.property\r\n        }\r\n      })\r\n    }\r\n\r\n    //Fixes formula filters from not working\r\n    if (collectionView?.query2?.filter?.filters) {\r\n      filters.push(...collectionView.query2.filter.filters)\r\n    }\r\n\r\n    let loader: any = {\r\n      type: 'reducer',\r\n      reducers: {\r\n        collection_group_results: {\r\n          type: 'results',\r\n          limit,\r\n          loadContentCover\r\n        }\r\n      },\r\n      sort: [],\r\n      ...collectionView?.query2,\r\n      filter: {\r\n        filters: filters,\r\n        operator: 'and'\r\n      },\r\n      searchQuery,\r\n      userTimeZone\r\n    }\r\n\r\n    if (groupBy) {\r\n      const groups =\r\n        collectionView?.format?.board_columns ||\r\n        collectionView?.format?.collection_groups ||\r\n        []\r\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\r\n      const operators = {\r\n        checkbox: 'checkbox_is',\r\n        url: 'string_starts_with',\r\n        text: 'string_starts_with',\r\n        select: 'enum_is',\r\n        multi_select: 'enum_contains',\r\n        created_time: 'date_is_within',\r\n        ['undefined']: 'is_empty'\r\n      }\r\n\r\n      const reducersQuery = {}\r\n      for (const group of groups) {\r\n        const {\r\n          property,\r\n          value: { value, type }\r\n        } = group\r\n\r\n        for (const iterator of iterators) {\r\n          const iteratorProps =\r\n            iterator === 'results'\r\n              ? {\r\n                  type: iterator,\r\n                  limit\r\n                }\r\n              : {\r\n                  type: 'aggregation',\r\n                  aggregation: {\r\n                    aggregator: 'count'\r\n                  }\r\n                }\r\n\r\n          const isUncategorizedValue = typeof value === 'undefined'\r\n          const isDateValue = value?.range\r\n          // TODO: review dates reducers\r\n          const queryLabel = isUncategorizedValue\r\n            ? 'uncategorized'\r\n            : isDateValue\r\n            ? value.range?.start_date || value.range?.end_date\r\n            : value?.value || value\r\n\r\n          const queryValue =\r\n            !isUncategorizedValue && (isDateValue || value?.value || value)\r\n\r\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\r\n            ...iteratorProps,\r\n            filter: {\r\n              operator: 'and',\r\n              filters: [\r\n                {\r\n                  property,\r\n                  filter: {\r\n                    operator: !isUncategorizedValue\r\n                      ? operators[type]\r\n                      : 'is_empty',\r\n                    ...(!isUncategorizedValue && {\r\n                      value: {\r\n                        type: 'exact',\r\n                        value: queryValue\r\n                      }\r\n                    })\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\r\n      loader = {\r\n        type: 'reducer',\r\n        reducers: {\r\n          [reducerLabel]: {\r\n            type: 'groups',\r\n            groupBy,\r\n            ...(collectionView?.query2?.filter && {\r\n              filter: collectionView?.query2?.filter\r\n            }),\r\n            groupSortPreference: groups.map((group) => group?.value),\r\n            limit\r\n          },\r\n          ...reducersQuery\r\n        },\r\n        ...collectionView?.query2,\r\n        searchQuery,\r\n        userTimeZone,\r\n        //TODO: add filters here\r\n        filter: {\r\n          filters: filters,\r\n          operator: 'and'\r\n        }\r\n      }\r\n    }\r\n\r\n    // if (isBoardType) {\r\n    //   console.log(\r\n    //     JSON.stringify(\r\n    //       {\r\n    //         collectionId,\r\n    //         collectionViewId,\r\n    //         loader,\r\n    //         groupBy: groupBy || 'NONE',\r\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\r\n    //       },\r\n    //       null,\r\n    //       2\r\n    //     )\r\n    //   )\r\n    // }\r\n\r\n    return this.fetch<notion.CollectionInstance>({\r\n      endpoint: 'queryCollection',\r\n      body: {\r\n        collection: {\r\n          id: collectionId\r\n        },\r\n        collectionView: {\r\n          id: collectionViewId\r\n        },\r\n        loader\r\n      },\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async getUsers(\r\n    userIds: string[],\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n  ) {\r\n    return this.fetch<notion.RecordValues<notion.User>>({\r\n      endpoint: 'getRecordValues',\r\n      body: {\r\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\r\n      },\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async getBlocks(\r\n    blockIds: string[],\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n  ) {\r\n    return this.fetch<notion.PageChunk>({\r\n      endpoint: 'syncRecordValues',\r\n      body: {\r\n        requests: blockIds.map((blockId) => ({\r\n          // TODO: when to use table 'space' vs 'block'?\r\n          table: 'block',\r\n          id: blockId,\r\n          version: -1\r\n        }))\r\n      },\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async getSignedFileUrls(\r\n    urls: types.SignedUrlRequest[],\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n  ) {\r\n    return this.fetch<types.SignedUrlResponse>({\r\n      endpoint: 'getSignedFileUrls',\r\n      body: {\r\n        urls\r\n      },\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async search(\r\n    params: notion.SearchParams,\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n  ) {\r\n    const body = {\r\n      type: 'BlocksInAncestor',\r\n      source: 'quick_find_public',\r\n      ancestorId: parsePageId(params.ancestorId),\r\n      sort: 'Relevance',\r\n      limit: params.limit || 20,\r\n      query: params.query,\r\n      filters: {\r\n        isDeletedOnly: false,\r\n        isNavigableOnly: false,\r\n        excludeTemplates: true,\r\n        requireEditPermissions: false,\r\n        ancestors: [],\r\n        createdBy: [],\r\n        editedBy: [],\r\n        lastEditedTime: {},\r\n        createdTime: {},\r\n        ...params.filters\r\n      }\r\n    }\r\n\r\n    return this.fetch<notion.SearchResults>({\r\n      endpoint: 'search',\r\n      body,\r\n      gotOptions\r\n    })\r\n  }\r\n\r\n  public async fetch<T>({\r\n    endpoint,\r\n    body,\r\n    gotOptions,\r\n    headers: clientHeaders\r\n  }: {\r\n    endpoint: string\r\n    body: object\r\n    gotOptions?: OptionsOfJSONResponseBody\r\n    headers?: any\r\n  }): Promise<T> {\r\n    const headers: any = {\r\n      ...clientHeaders,\r\n      ...gotOptions?.headers,\r\n      'Content-Type': 'application/json'\r\n    }\r\n\r\n    if (this._authToken) {\r\n      headers.cookie = `token_v2=${this._authToken}`\r\n    }\r\n\r\n    if (this._activeUser) {\r\n      headers['x-notion-active-user-header'] = this._activeUser\r\n    }\r\n\r\n    const url = `${this._apiBaseUrl}/${endpoint}`\r\n\r\n    return got\r\n      .post(url, {\r\n        ...gotOptions,\r\n        json: body,\r\n        headers\r\n      })\r\n      .json()\r\n\r\n    // return fetch(url, {\r\n    //   method: 'post',\r\n    //   body: JSON.stringify(body),\r\n    //   headers\r\n    // }).then((res) => {\r\n    //   console.log(endpoint, res)\r\n    //   return res.json()\r\n    // })\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}